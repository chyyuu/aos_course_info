<h2>C Summary of major innovations</h2>
<p>之前的研究专注于使用交换操作的推导并行操作的安全性，而这篇论文中作为之前方法的补充：使用运行操作的交换性推导程序的扩展性。当操作交换后其执行结果与各程序的执行顺序相互独立。因此，程序交换操作之间的通信就没必要实现并消除这一中间环节就可以实现无冲突。
</p>
<p>
通常的交换规则都很严格以至于很少应用到带有复杂的、有状态的接口等的常见系统软件里面。与此相反，SIM交换规则是状态相互独立的、基于接口的并且是单调性的。当在具体的系统状态、具体的操作参数和具体的并行操作环境中执行交换操作时，实验表明对于这些状态、参数和并行操作这些无冲突的操作都是可以实现的。尽管逻辑状态相互依赖，而SIM的交换操作是基于接口的：不是要求所有操作序列产生完全相似的内部状态，而是需要结果状态通过接口进行区分。从而SIM交换操作独立于任何具体应用，这样可以使得开发者直接在接口上应用这些规则。
</p>
<p>
该论文方法的核心是可扩展的交换规则：任何情况下的交换操作即意味着通过接口无法区分他们的执行顺序，这样可以实现在交换操作中的无冲突内存访问。更准确地说，任何时候的接口交换操作，他们可以以扩展的方式应用。
</p>
<p>
这样的交换规则催生了一种新的可扩展软件开发方式：首先分析接口的可交换性然后就在可进行交换操作的情况下设计相应的软件。
</p>
<p>
在多核处理器上，其中的任何一个核可以唯一地扩展其读和写由其缓冲的数据并且以共享模式扩展其读数据机制。当内存访问没有冲突时，增加核数会在吞吐量上产生线性增长的效应。
</p>
<h2>C What the problems the paper mentioned?</h2>
<p>
评估多核软件可扩展性的当前技术是选择一个工作集，基于不同数量内核绘制相应的性能分析结果，并使用如差分分析等的工具以确定可扩展性瓶颈。这使得开发者可以集中解决实的际问题。但存在几个缺点，不同的工作集及更多的内核经常导致新的瓶颈出现。由于并不清楚具体哪个瓶颈是最根本的，这就使得开发者在并未意识到一种可扩展解决方案可行的情况下放弃分析对应的问题。最终，这一过程在程序运行过程中出现的太晚以至于像改进型的接口这样设计级别的解决方案很可能并不实用。
</p>
<h2>C How about the important related works/papers?</h2>
<p>
Israeli和Rappoport引进了互斥并行访问内存系统的概念。大概情况就是如果一个共享内存系统的机制是互斥并行访问并且多个进程访问互斥的内存位置，那么这些程序存在线性的扩展性。正如交换规则一样，上面提到的是一个有条件的保证：如果一个应用程序以一种特殊的方式使用共享内存，那么共享内存的使用将会得到扩展。但是，在互斥并行访问专门针对内存系统接口设计时，我们的运用访问包括任何软件接口。Attiay等扩展了Israeli和Rappoport的定义，在他们基础之上需要额外的无冲突操作从而可以得到扩展。这些实现都有待于补充。
</p>
<h2>C What are some intriguing aspects of the paper?</h2>
<p>使用COMMUTER工具自动对结果进行推导。</p>
<p>实现交换规则的算法等。</p>
<p>使用一个基于抽象软件操作、历史记录和对应的实施阶段的规范化得出扩展性交换规则的准确定义的方法，测试这种规则的实验方法等。</p>
<h2>C How to test/compare/analyze the results?</h2>
<p>
使用包括用户空间和库代码的sv6。采用其他交换操作和其他一些修改过的POSIX应用程序。在集成80个内核的带有8个2.4GHz的10核的InterE7-8870芯片和256GB的RAM上运行测试程序。
</p>
<p>
设计并使用一个类似ramfs的内存文件系统ScaleFS和一个基于xv6的虚拟内核。RadixVM和ScaleFS都是由交换规则引导。对于ScaleFS，高度依赖于COMMUTER吞吐量来指导其设计并且在应用过程中找到共享存在的问题。ScaleFS为了提高扩展性对存在的技术进行扩展使用，例如单核资源分配，双检查锁定等。
</p>